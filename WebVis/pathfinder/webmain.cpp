
#define TEST false

#include <iostream>
#if !TEST
#include <chrono>
#include <sstream>
#include <getopt.h>
#include <string>
#include <vector>
#include <algorithm>
//#include "moves/MoveManager.h"
//#include "search/ConfigurationSpace.h"
//#include <boost/format.hpp>
#include <nlohmann/json.hpp>
//#include "lattice/LatticeSetup.h"
//#include "moves/Scenario.h"
//#include "search/SearchAnalysis.h"
//#include "search/HeuristicCache.h"
#include "../../pathfinder/coordtensor/CoordTensor.h"
#include "../../pathfinder/utility/color_util.h"
#endif

#ifdef __EMSCRIPTEN__
#include <emscripten.h>
#endif

#if !TEST
struct ScenInfo {
    //std::string exportFile;
    std::string scenName;
    std::string scenDesc;
};

std::string TryGetScenName(const std::string& str) {
    nlohmann::json stateJson = nlohmann::json::parse(str);
    if (stateJson.contains("name")) {
        return stateJson["name"];
    }
    std::string name = std::filesystem::path(str).filename().stem().string();
    if (std::size_t trimPos = name.find("_initial"); trimPos != std::string::npos) {
        name.erase(trimPos, 8);
    }
    return name;
}

std::string TryGetScenDesc(const std::string& str) {
    nlohmann::json stateJson = nlohmann::json::parse(str);
    if (stateJson.contains("description")) {
        return stateJson["description"];
    }
    return "Scenario file generated by PLACEHOLDER WEB PATHFINDER.";
}
#endif

extern "C" {
    const char* pathfinder(char* config_initial, char* config_final) {
#if TEST
        std::cout << "TEST" << std::endl;
#else
        bool ignoreColors = false;
        std::string initialStr = config_initial;
        std::string finalStr = config_final;
    //    std::string exportFile = "../Scenarios/Pathfinder.scen";
    //    std::string analysisFile;
    //    std::string movesFolder;
        std::string searchMethod = "A*";
        std::string heuristic = "MRSH-1";

        // Print some useful information (no idea what this stuff'll do in web version, maybe it still logs to console?)
        std::cout << std::endl << "Module Representation: ";
    #if MODULEMANAGER_DATA_STORAGE == MM_DATA_FULL
        std::cout << "FULL" << std::endl;
    #elif MODULEMANAGER_DATA_STORAGE == MM_DATA_INT64
        std::cout << "INT64" << std::endl;
    #else
        std::cout << "INVALID" << std::endl;
    #endif
        std::cout << "Final State Generator: ";
    #if GENERATE_FINAL_STATE
        std::cout << "ENABLED" << std::endl;
    #else
        std::cout << "DISABLED" << std::endl;
    #endif
        std::cout << "Edge Check Mode:       ";
    #if LATTICE_RD_EDGECHECK
        std::cout << "RHOMBIC DODECAHEDRON FACE" << std::endl;
    #else
        std::cout << "CUBE FACE" << std::endl;
    #endif
        std::cout << "Parallel Pathfinding:  ";
    #if CONFIG_PARALLEL_MOVES
        std::cout << "ENABLED" << std::endl;
    #else
        std::cout << "DISABLED" << std::endl;
    #endif
        std::cout << "Search Method:         ";
        if (searchMethod.empty() || searchMethod == "A*" || searchMethod == "a*") {
            std::cout << "A*" << std::endl;
            std::cout << "└Heuristic:            ";
            if (heuristic.empty() || heuristic == "MRSH1" || heuristic == "mrsh1" || heuristic == "MRSH-1" || heuristic == "mrsh-1") {
                std::cout << "MRSH-1" << std::endl;
                std::cout << " ├L1 Distance Limits:  ";
    #if CONFIG_HEURISTIC_CACHE_OPTIMIZATION
                std::cout << "ENABLED" << std::endl;
    #else
                std::cout << "DISABLED" << std::endl;
    #endif
                std::cout << " ├L2 Distance Limits:  ";
    #if CONFIG_HEURISTIC_CACHE_DIST_LIMITATIONS
                std::cout << "ENABLED" << std::endl;
    #else
                std::cout << "DISABLED" << std::endl;
    #endif
                std::cout << " └Help Limits:         ";
    #if CONFIG_HEURISTIC_CACHE_HELP_LIMITATIONS
                std::cout << "ENABLED" << std::endl;
    #else
                std::cout << "DISABLED" << std::endl;
    #endif
            } else if (heuristic == "Symmetric Difference" || heuristic == "symmetric difference" || heuristic == "SymDiff" || heuristic == "symdiff") {
                std::cout << "Symmetric Difference" << std::endl;
            } else if (heuristic == "Manhattan" || heuristic == "manhattan") {
                std::cout << "Center of Mass Manhattan" << std::endl;
            } else if (heuristic == "Chebyshev" || heuristic == "chebyshev") {
                std::cout << "Center of Mass Chebyshev" << std::endl;
            } else if (heuristic == "Nearest Chebyshev" || heuristic == "nearest chebyshev") {
                std::cout << "Nearest Chebyshev" << std::endl;
            }
        } else if (searchMethod == "BFS" || searchMethod == "bfs") {
            std::cout << "BFS" << std::endl;
        }
        std::cout << std::endl;

        // Web Demo (load files)
        nlohmann::json j_i, j_f;
        //std::ifstream i_file = std::ifstream(initialStr);
        //std::ifstream f_file = std::ifstream(finalStr);
        j_i = nlohmann::json::parse(initialStr);
        j_f = nlohmann::json::parse(finalStr);
        std::cout << "file streams instantiated." << std::endl;

        if (!j_i["exists"]) {
            std::cout << "No initial configuration provided! Pathfinder exiting." << std::endl;
        }
        if (!j_f["exists"]) {
            std::cout << "No final configuration provided! Pathfinder exiting." << std::endl;
        }

        int order = j_i["order"];
        int axisSize = j_i["axisSize"];

        CoordTensor<int> tensor_i(order, axisSize, -1), tensor_f(order, axisSize, -1);
        std::vector<std::vector<int>> coords_i, coords_diff_i, coords_diff_f;
        std::cout << "vectors initialized" << std::endl;

        ScenInfo scen_info;
        //scen_info.exportData = "";
        scen_info.scenName = TryGetScenName(initialStr);
        scen_info.scenDesc = TryGetScenDesc(initialStr);
        std::cout << "scen info initialized" << std::endl;
        std::stringstream scen_out;
        std::cout << "stringstream initialized" << std::endl;
        scen_out << scen_info.scenName << std::endl << scen_info.scenDesc << std::endl;
        scen_out << "CUBE\n\n";
        scen_out << "0, 244, 244, 0, 95\n";
        scen_out << "1, 255, 255, 255, 85\n\n";
        std::cout << "header sent to stringstream" << std::endl;

        int group_num = 0;
        int mod_id = 0;
        for (const auto& module : j_i["modules"]) {
            group_num = ++group_num % 2;
            mod_id++;
            std::vector<int> position = module["position"];
            std::valarray<int> coords(position.data(), position.size());
    //        std::transform(position.begin(), position.end(), position.begin(),
    //                    [](const int coord) { return coord; });
            scen_out << mod_id << ", " << group_num << ", " << coords[0] << ", " << coords[1] << ", " << (position.size() < 3 ? 0 : coords[2]) << "\n";
            tensor_i[coords] = mod_id;
            if (!module["static"]) {
                coords_diff_i.push_back(position);
            }
        }
        std::cout << "math 1" << std::endl;

        scen_out << "\n";

        for (const auto& module : j_f["modules"]) {
            std::vector<int> position = module["position"];
            std::valarray<int> coords(position.data(), position.size());
            if (!std::any_of(coords_i.begin(), coords_i.end(), [position](std::vector<int> i_coords) {
                    return i_coords[0] == position[0] && i_coords[1] == position[1] && i_coords[2] == position[2];
                })) {
                coords_diff_f.push_back(position);
            } else {
                auto idx = std::find(coords_diff_i.begin(), coords_diff_i.end(), position);
                std::cout << "found pos at " << idx - coords_diff_i.begin() << "/" << coords_diff_i.size() << std::endl;
                coords_diff_i.erase(idx);
    //            std::remove(coords_diff_i.begin(), coords_diff_i.end(), position);
                coords_i.push_back(position);
            }
        }

//        if (coords_diff_i.size() != coords_diff_f.size()) {
//            std::vector<int> indicesToFree;
//            for (int i = 0; i < coords_diff_i.size(); i++) {
//                if (!std::any_of(coords_diff_f.begin(), coords_diff_f.end(), [coords_diff_i, i](std::vector<int> f_coords) {
//                    return f_coords[0] == coords_diff_i[i][0] && f_coords[1] == coords_diff_i[i][1] && f_coords[2] == coords_diff_i[i][2];
//                })) {
//                    indicesToFree.push_back(i);
//                }
//            }
//            int indicesFreed = 0;
//            std::sort(indicesToFree.begin(), indicesToFree.end());
//            for (const auto i : indicesToFree) {
//                coords_i.push_back(coords_diff_i[i - indicesFreed]);
//                coords_diff_i.erase(coords_diff_i.begin() + i - indicesFreed);
//                indicesFreed++;
//            }
//        }
        std::cout << "math 2" << std::endl;

        for (int i = 0; i < coords_diff_f.size(); i++) {
            std::valarray<int> i_coord = std::valarray<int>(coords_diff_i[i].data(), coords_diff_i[i].size());
            mod_id = tensor_i[i_coord];
            //yarp
            scen_out << "*" << mod_id << ", 0, " << coords_diff_f[i][0] - coords_diff_i[i][0] << ", "
                     << coords_diff_f[i][1] - coords_diff_i[i][1] << ", "
                     << (coords_diff_f[i].size() < 3 ? 0 : coords_diff_f[i][2] - coords_diff_i[i][2]) << "\n\n";
        }
        std::cout << "scen finished" << std::endl;

#endif
        //free(config_initial);
        //free(config_final);
        //std::cout << "input strings freed" << std::endl;
        std::string scenStr = scen_out.str();
        std::cout << "scen string made" << std::endl;

        return scenStr.c_str();
    }
}